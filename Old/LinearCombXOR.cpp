#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<cstdlib>
#include"FSR.h"
#include"LFSR.h"
#include"NFSR.h"

std::vector<bool> values = { 0,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,1,1,
	1,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,1,
	1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,1,0,1,1,1,0,0,1,1,0,0,1,0,1,1,0,1,0,1,1,1,0,0,1,0,1,
	0,1,1,0,0,1,0,1,0,0,1,0,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,1,1,0,0,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,1,0,0,1,
	0,0,1,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0 };

bool feedback_(std::vector<bool> x) {
	size_t index = 0;
	for (size_t i = 0; i < x.size(); i++) {
		index <<= 1;
		if (x[i]) {
			index++;
		}
	}
	return values[index];
}

bool feedback(std::vector<bool> x) {
	return feedback_({ x[0],x[8],x[9],x[16],x[17],x[24],x[27],x[28] });
}


void wtf(std::vector<FSR*> regs1, std::vector<FSR*> regs2) {
	for (size_t i = 0; i < 32; i++) {
		for (size_t j = 0; j < 4; j++) {
			regs1[j]->shift();
			regs2[j]->shift();
		}
	}
	for (size_t i = 0; i < 655360; i++) {
		/*size_t rly = 0;
		for (size_t j = 0; j < 8; j++) {
			rly <<= 4;
			rly += (regs1[0]->shift() ^ regs2[0]->shift()) * 8 + (regs1[1]->shift() ^ regs2[1]->shift()) * 4 +
				(regs1[2]->shift() ^ regs2[2]->shift()) * 2 + (regs1[3]->shift() ^ regs2[3]->shift());
			//rly += cfr->shift();
		}

		std::cout << rly << std::endl;*/

		unsigned char val = 0;
		unsigned char mask = 0xFE;

		for (size_t j = 0; j < 8; j++) {
			for (size_t k = 0; k < 1; k++) {
				val = (val << 1)&mask | ((regs1[0]->shift() ^ regs2[0]->shift()));// ^ (regs1[1]->shift() ^ regs2[1]->shift())&(regs1[2]->shift() ^ regs2[2]->shift()) ^ (regs1[1]->shift() ^ regs2[1]->shift()) & (regs1[3]->shift() ^ regs2[3]->shift()) ^ (regs1[2]->shift() ^ regs2[2]->shift()) & (regs1[3]->shift() ^ regs2[3]->shift()));
			}
		}



		std::cout << val;
	}
}

int main() {
	freopen("xortest.txt", "w", stdout);
	std::vector<FSR*> regs1 = {
		new LFSR({0,1,0,1,1,1,1,1,1,1,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,0,1,0,0,0}, {32,22,2,1}),
		new LFSR({1,0,1,1,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1}, { 32,16,7,2 }),
		new LFSR({0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1, 0,1,0,1,0,1,1,1, 1,0,1,1,1,0,0,1}, {32,30,17,12,3,1}),
		new LFSR({1,1,0,1,1,1,1,1, 0,0,1,1,0,0,0,1, 1,0,0,0,0,0,0,1, 0,1,1,0,1,0,0}, {31,3})
	};

	std::vector<FSR*> regs2 = {
		/*new LFSR({0,1,0,1,1,1,1,1,1,1,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,0,1,0,0,0}, {32,30,17,12,3,1}),
		new LFSR({0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1, 0,1,0,1,0,1,1,1, 1,0,1,1,1,0,0} , {31,3} ),
		new LFSR({1,1,0,1,1,1,1,1, 0,0,1,1,0,0,0,1, 1,0,0,0,0,0,0,1, 0,1,1,0,1,0,1,0} ,  { 32,16,7,2 }),
		new LFSR({1,0,1,1,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1}, {32,22,2,1})*/
		new NFSR({ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 }, feedback),
		new NFSR({ 1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0 }, feedback),
		new NFSR({ 0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1 }, feedback),
		new NFSR({ 1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1 }, feedback)
	};

	wtf(regs1, regs2);

	
	regs1[0]->setState({ 1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,1,0,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0 });
	regs1[1]->setState({ 0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,0,0,1,0,1,1,0 });
	regs1[2]->setState({ 0,0,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,0,1,1,1,0,1,1,0,1,0 });
	regs1[3]->setState({ 1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1 });
	regs2[0]->setState({ 0,0,0,1,1,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1 });
	regs2[1]->setState({ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0 });
	regs2[2]->setState({ 1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1 });
	regs2[3]->setState({ 1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,0,0,1 });

	wtf(regs1, regs2);

	regs1[0]->setState(712345);
	regs1[1]->setState(18723858);
	regs1[2]->setState(8172538);
	regs1[3]->setState(4294720912);
	regs2[0]->setState(18725982);
	regs2[1]->setState(3098102971);
	regs2[2]->setState(129083);
	regs2[3]->setState(198263875);

	wtf(regs1, regs2);
	
	return 0;
}